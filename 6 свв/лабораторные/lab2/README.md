# Лабораторная работа №2

## Вариант `1`

<img alt="lain-wake-up" src="https://github.com/maxbarsukov/itmo/blob/master/.docs/lain-wake-up.gif" height="350">

|.pdf|.docx|
|-|-|
| [report](./docs/report.pdf) | [report](./docs/report.docx) |

---

## Задание

**«Основы написания драйверов устройств с использованием операционной системы»**

| Презентация | Шаблон ЛР |
| --- | --- |
| [task/lab2_slides.pdf](./task/lab2_slides.pdf) | [task/ch_drv.zip](./task/ch_drv.zip) |

**Цель работы:** Познакомится с основами разработки драйверов устройств с использованием операционной системы на примере создания драйверов символьных устройств под операционную систему Linux.

ПО для выполнения работы:

- `qemu-system-riscv62`;
- ОC `Linux`;
- `RISC-V C/ASM` окружение для сборки проектов (на базе LLVM).

### Задание к лабораторной работе

1. Написать драйвер символьного устройства, удовлетворяющий требованиям:
    - должен создавать символьное устройство `/dev/varN`, где `N` – это номер варианта;
    - должен обрабатывать операции записи и чтения в соответствии с вариантом задания.
2. Оформить отчет по работе в электронном формате.

## Варианты

| № варианта | Описание |
| --- | --- |
| 1 | При записи текста в файл символьного устройства должен осуществляться подсчет введенных символов. Последовательность полученных результатов (количество символов) с момента загрузки модуля ядра должна выводиться при чтении файла. |
| 2 | При записи текста в файл символьного устройства должно запоминаться количество пробелов во введенном тексте. Последовательность полученных результатов с момента загрузки модуля ядра должна выводиться при чтении файла. |
| 3 | При записи текста в файл символьного устройства должно запоминаться количество введенных букв (не буквы на считаются). Последовательность полученных результатов с момента загрузки модуля ядра должна выводиться при чтении файла. |
| 4 | При записи текста в файл символьного устройства должен осуществляться подсчет введенных цифр. Последовательность полученных результатов (количество цифр) с момента загрузки модуля ядра должна выводиться при чтении файла. |

## Требования к отчету

1. На титульном листе должны быть приведены следующие данные:
    - Название дисциплины;
    - Номер и название лабораторной работы;
    - ФИО исполнителя и группа.
2. Во введении указываются цели и задачи работы.
3. В основной части приводится описание функций, являющихся обработчиками системных вызовов ОС Linux на чтение и запись, а также вызываемых в этих обработчиках других функций.
4. Приводятся скриншоты вывода в консоль данных при всех возможных сценариях использования драйвера.

---

## Как запустить?

> [!TIP]
> В исходной инструкции по запуску ЛР предлагается с помощью `apt` установить пакеты `opensbi` и `u-boot-qemu` для `riscv64`. Однако если ваша хост-система это не Ubuntu/Debian, то скорее всего возникнут проблемы, и файлов, необходимых для запуска QEMU, вы не найдёте. \
> Поэтому все нужные для запуска файлы ([`uboot.elf`](./build/uboot/uboot.elf) и [`fw_jump.bin`](./build/opensbi/fw_jump.bin)) я собрал сам. Если вы будете следовать этому руководству и использовать файлы из [`./build`](./build/) и скрипт [`run.sh`](./run.sh), то проблем возникнуть не должно.

### Установка окружения

1. Скачиваем архив с образом `Ubuntu-20.04.5-preinstalled-server-riscv64`:

        wget https://cdimage.ubuntu.com/releases/20.04/release/ubuntu-20.04.5-preinstalled-server-riscv64+unmatched.img.xz -O build/ubuntu.img.xz

2. Распаковываем архив:

        xz -dk ./build/ubuntu.img.xz

3. Расширяем образ на 5 Гб:

        qemu-img resize -f raw ./build/ubuntu.img +5G

5. Запускаем QEMU на машине `virt` с использованием `OpenSBI` в качестве BIOS, `UBoot` в качестве Bootloader и `Ubuntu` в качестве ОС:

        ./run.sh

### Настройка Ubuntu

1. При первой загрузке используем эти логин и пароль:

        login: ubuntu
        pass: ubuntu

2. И устанавливаем новый, например:

        new password: password

3. Увеличьте ширину консоли для удобства работы:

        stty cols 132

### Сборка и запуск

> [!NOTE]
> Если **пустой** пример файла устройства **нормально пишется/читается**, а после выполнения задания при вызове кидает **ошибку** `no such device or address` при том, что **модуль загружен**, в `dmesg` нет логов об ошибках, а файл устройства есть в `/dev` – то проблема в вашем файле. В моем случае достаточно было переписать ЛР с использования `kmalloc`/`kfree` на статическое выделение памяти, чтобы нормально использовать файл устройства.

1. Изменяем [`ch_drv.c`](./ch_drv.c) согласно варианту.
2. Передаем необходимые для сборки файлы в виртуальную машину QEMU:

        scp -P 2222 ch_drv.c Makefile ubuntu@localhost:/home/ubuntu/

3. Подключаемся к виртуальной машине с помощью `ssh` в отдельном терминале:

        ssh ubuntu@localhost -p 2222

4. Устанавливаем пакеты для сборки модуля ядра:

        sudo apt-get update
        sudo apt install build-essential

5. Собираем:

        make

6. Загружаем модуль ядра:

        # если модуль уже загружен, то предварительно:
        # sudo rmmod ch_drv
        sudo insmod ch_drv.ko

7. Проверяем, что модуль подключился и читаем кольцевой буфер ядра с отладочной информацией:

        lsmod | grep ch_drv
        dmesg | tail -n 20

7. Пишем/читаем файл устройства `/dev/varN`, где `N` – это номер варианта:

        echo "Hello" | sudo tee /dev/varN
        cat /dev/varN

## Полезные ссылки

| Ссылка | Описание |
| --- | --- |
| [J. Corbet, A. Rubini, G. Kroah-Hartman. Linux Device Drivers. Third Edition. 2005. P. 638](https://bootlin.com/doc/books/ldd3.pdf) | Классическая книга по разработке драйверов для Linux |
| [rus-linux.net/MyLDP/BOOKS/drivers/linux-device-drivers-00.html](https://rus-linux.net/MyLDP/BOOKS/drivers/linux-device-drivers-00.html) | Драйвера устройств в Linux (перевод Linux Device Drivers Series") |
| [syntacore.com/tools/development-tools](https://syntacore.com/tools/development-tools) | Инструменты разработки под ОС Linux для RISC-V и образ Linux для QEMU |
| [www.kernel.org/doc/html/latest/kbuild/modules.html](https://www.kernel.org/doc/html/latest/kbuild/modules.html) | Информация по сборке внешнего модуля ядра |
| [linux-kernel-labs.github.io/refs/heads/master/labs/device_drivers.html](https://linux-kernel-labs.github.io/refs/heads/master/labs/device_drivers.html) | Информация о символьных устройствах |
| [ru.stackoverflow.com/questions/965630](https://ru.stackoverflow.com/questions/965630/%D0%94%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2) | Для чего нужны файлы устройств? |
| [github.com/XVIIStarPlatinum/ITMO/Software Engineering/IO Systems/Lab2](https://github.com/XVIIStarPlatinum/ITMO/tree/master/Software%20Engineering/IO%20Systems/Lab2) | Выполнение 1-го варианта ЛР2 |
| [github.com/Imtjl/io-systems/kernel-char-driver](https://github.com/Imtjl/io-systems/tree/main/kernel-char-driver) | Выполнение 2-го варианта ЛР2 |

## Лицензия <a name="license"></a>

Проект доступен с открытым исходным кодом на условиях [Лицензии GNU GPL 3](https://opensource.org/license/gpl-3-0/). \
*Авторские права 2025 Max Barsukov*

**Поставьте звезду :star:, если вы нашли этот проект полезным.**
