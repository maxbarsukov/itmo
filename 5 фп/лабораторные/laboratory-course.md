# Функциональное программирование. Лабораторный курс

Цель лабораторного курса: получение практических навыков программирования в функциональной парадигме.

Лабораторный курс сделан адаптируемым под интересы и нужды конкретного студента, поэтому доступны следующие степени свободы:

- Используемый язык программирования / технология согласуется студентом в рамках лабораторной работы №0.
- Лабораторная работа №4 претендует на решение задач, отражающих специфику выбранного языка. Учащимся предоставляется возможность предложить свою задачу в качестве варианта. При этом, данная задача может решаться как индивидуально, так и группой студентов.

## Описание лабораторных работ

Все лабораторные работы, кроме четвертой, выполняются и защищаются индивидуально.

0. Эссе. Выбор языка программирования и книги для чтения и подготовки к зачёту.
1. Простые алгоритмы и встроенные структуры данных. Задачи проекта Эйлер с разными способами реализации.
2. Работа с неизменяемыми и рекурсивными структурами данных (деревья, списки, функции высшего порядка), ленивые вычисления и бесконечные структуры данных. Тестирование.
3. Реализация одной из лабораторных работ по предмету "Вычислительная математика" с использованием функционального программирования. Ввод/вывод. Управление вычислительным процессом. Интерфейс командной строки.
4. Разработка приложения с учетом особенностей выбранного языка программирования.

Требования к исходным кодам лабораторных работ:

- должны быть размещены на Github, Gitlab ([сервер ИТМО](http://gitlab.se.ifmo.ru)) или аналогах;
- должны проходить настроенный вами CI, включая: прохождение тестов, прохождение выбранных lint tools (а они должны быть), автоматическое форматирование;
- история изменений в репозитории должна быть внятной (к примеру: повторная защита, преподаватель открывает историю изменений, видит какие замечания вы поправили и может смотреть индивидуальные diff-ы);
- при сборке и тестировании предупреждения должны быть включены и отсутствовать;
- весь исходный код в проекте должен быть отформатирован (включая вставки в `readme.md`);
- в репозитории не должно быть лишних файлов (артифактов сборки, ОС, конфигураций вашего любимого текстового редактора и т.п.).

Для прохождения лабораторного курса должны быть выполнены все лабораторные работы. Для допуска на комиссию по дисциплине необходимо сдать лабораторные работы 1, 2, 3.

### Лабораторная работа №0

Задачи:

1. поверхностное ознакомление с предлагаемыми к использованию технологиями по открытым источникам;
2. выбор языка программирования и подбор инструментальных средств (компилятор/интерпретатор, система сборки, системы автоматического форматирования, lint tools, инструменты тестирования, стиль кодирования);
3. написание эссе объёмом порядка страницы, в рамках которого необходимо:
   - [обосновать](https://dic.academic.ru/dic.nsf/enc_philosophy/847/ОБОСНОВАНИЕ) свой выбор языка программирования;
   - высказать соображения на предмет лабораторной работы номер 4;
   - привести планируемые к использованию инструментальные средства и список прочитанных статей / книг / руководств при подготовке эссе;
4. выбор книги, по которой вы будете знакомиться с технологией, текст которой необходимо показать на защите данной лабораторной работы и по которой вы будете готовиться к зачёту;
5. защита эссе, при этом возможны общие вопросы о невыбранных технологиях.

Примечания:

- при утверждении используемого языка программирования будет учитываться его популярность у ранее определившихся во избежание "курса по технологии Т";
    - ограничения: не более 20% на технологию (25% на Erlang+Elixir);
    - в случае блестящего обоснования -- ограничения могут быть нарушены;
- не любой язык программирования может быть утвержден;
- выбор языка программирования влияет на то, кто будет принимать лабораторные работы.
- если ваш язык не может быть утверждён:
    - вы можете его сменить,
    - вы можете подождать в надежде что другие студенты "снизят процент",
    - вы можете сделать свою аргументацию безупречной.

Варианты языков программирования:

- Haskell (хорошая система типов, бесточечный стиль, лень, квадратно/гнездовое программирование)
- Clojure (параллельное программирование, eDSL)
- Erlang/OTP (распределенные системы)
- Common Lisp (eDSL, CLOS, бесконечная гибкость)
- Ocaml
- Agda
- F#
- список открытый, предлагайте ваши варианты

Особое (т.к. стандартный набор лабораторных работ не очень применим):

- Coq (формальное доказательство свойств алгоритмов)

Не стоит:

- Rust (низкоуровневая разработка в функциональном стиле, уйдёте в особенности языка, а ФП будет по остаточному принципу);
- Scala, Kotlin (несмотря на отличные возможности с точки зрения ФП и системы типов, лучше выбрать что-то более функционально чистое).

### Лабораторная работа №1

Цель: освоить базовые приёмы и абстракции функционального программирования: функции, поток управления и поток данных, сопоставление с образцом, рекурсия, свёртка, отображение, работа с функциями как с данными, списки.

В рамках лабораторной работы вам предлагается решить несколько задач [проекта Эйлер](https://projecteuler.net/archives). Список задач -- ваш вариант.

Для каждой проблемы должно быть представлено несколько решений:

1. монолитные реализации с использованием:
   - хвостовой рекурсии;
   - рекурсии (вариант с хвостовой рекурсией не является примером рекурсии);
2. модульной реализации, где явно разделена генерация последовательности, фильтрация и свёртка (должны использоваться функции reduce/fold, filter и аналогичные);
3. генерация последовательности при помощи отображения (map);
4. работа со спец. синтаксисом для циклов (где применимо);
5. работа с бесконечными списками для языков, поддерживающих ленивые коллекции или итераторы как часть языка (к примеру Haskell, Clojure);
6. реализация на любом удобном для вас традиционном языке программирования для сравнения.

Требуется использовать идиоматичный для технологии стиль программирования.

Содержание отчёта:

- титульный лист;
- описание проблемы;
- ключевые элементы реализации с минимальными комментариями;
- выводы (отзыв об использованных приёмах программирования).

Примечания:

- необходимо понимание разницы между ленивыми коллекциями и итераторами;
- нужно знать особенности используемой технологии и того, как работают использованные вами приёмы.

### Лабораторная работа №2

Цель: освоиться с построением пользовательских типов данных, полиморфизмом, рекурсивными алгоритмами и средствами тестирования (unit testing, property-based testing), а также разделением интерфейса и особенностей реализации.

В рамках лабораторной работы вам предлагается реализовать одну из предложенных классических структур данных (список, дерево, бинарное дерево, hashmap, граф...).

Требования:

1. Функции:
    - добавление и удаление элементов;
    - фильтрация;
    - отображение (map);
    - свертки (левая и правая);
    - структура должна быть [моноидом](https://ru.m.wikipedia.org/wiki/Моноид).
2. Структуры данных должны быть неизменяемыми.
3. Библиотека должна быть протестирована в рамках unit testing.
4. Библиотека должна быть протестирована в рамках property-based тестирования (как минимум 3 свойства, включая свойства моноида).
5. Структура должна быть полиморфной.
6. Требуется использовать идиоматичный для технологии стиль программирования. Примечание: некоторые языки позволяют получить большую часть API через реализацию небольшого интерфейса. Так как лабораторная работа про ФП, а не про экосистему языка -- необходимо реализовать их вручную и по возможности -- обеспечить совместимость.
7. Обратите внимание:
    - API должно быть реализовано для заданного интерфейса и оно не должно "протекать". На уровне тестов -- в первую очередь нужно протестировать именно API (dict, set, bag).
    - Должна быть эффективная реализация функции сравнения (не наивное приведение к спискам, их сортировка с последующим сравнением), реализованная на уровне API, а не внутреннего представления.

Содержание отчёта:

- титульный лист;
- требования к разработанному ПО;
- ключевые элементы реализации с минимальными комментариями;
- тесты, отчет инструмента тестирования, метрики;
- выводы (отзыв об использованных приёмах программирования).

Варианты (колонка -- интерфейс, строка -- структура данных):

|                           | Dict       | Bag(multiset) | Set       |
|---------------------------|------------|---------------|-----------|
| AVL Tree                  | `avl-dict` | `avl-bag`     | `avl-set` |
| Prefix Tree               | `pre-dict` | `pre-bag`     | `pre-set` |
| OpenAddress Hashmap       | `oa-dict`  | `oa-bag`      | `oa-set`  |
| Separate Chaining Hashmap | `sc-dict`  | `sc-bag`      | `sc-set`  |
| RedBlack Tree             | `rb-dict`  | `rb-bag`      | `rb-set`  |
| Binary Tree               | `bt-dict`  | `bt-bag`      | `br-set`  |

### Лабораторная работа №3

Цель: получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой.

В рамках лабораторной работы вам предлагается повторно реализовать лабораторную работу по предмету "Вычислительная математика" посвящённую интерполяции (в разные годы это лабораторная работа 3 или 4) со следующими дополнениями:

- обязательно должна быть реализована линейная интерполяция (отрезками, [link](https://en.wikipedia.org/wiki/Linear_interpolation));
- настройки алгоритма интерполяции и выводимых данных должны задаваться через аргументы командной строки:
    - какие алгоритмы использовать (в том числе два сразу);
    - частота дискретизации результирующих данных;
    - и т.п.;
- входные данные должны задаваться в текстовом формате на подобии ".csv" (к примеру `x;y\n` или `x\ty\n`) и подаваться на стандартный ввод, входные данные должны быть отсортированы по возрастанию x;
- выходные данные должны подаваться на стандартный вывод;
- программа должна работать в потоковом режиме (пример -- `cat | grep 11`), это значит, что при запуске программы она должна ожидать получения данных на стандартный ввод, и, по мере получения достаточного количества данных, должна выводить рассчитанные точки в стандартный вывод;

Приложение должно быть организовано следующим образом:

```text
    +---------------------------+
    | обработка входного потока |
    +---------------------------+
            |
            | поток / список / последовательность точек
            v
    +-----------------------+      +------------------------------+
    | алгоритм интерполяции |<-----| генератор точек, для которых |
    +-----------------------+      | необходимо вычислить         |
            |                      | промежуточные значения       |
            |                      +------------------------------+
            |
            | поток / список / последовательность рассчитанных точек
            v
    +------------------------+
    | печать выходных данных |
    +------------------------+
```

Потоковый режим для алгоритмов, работающих с группой точек должен работать следующим образом:

```text
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
        x x x . . o . . x x x
          x x x . . o . . x x x
            x x x . . o o o o o o EOF
```

где:

- каждая строка -- окно данных, на основании которых производится расчёт алгоритма;
- строки сменяются по мере поступления в систему новых данных (старые данные удаляются из окна, новые -- добавляются);
- `o` -- рассчитанные данные, можно видеть:
    - большинство окон используется для расчёта всего одной точки, так как именно в "центре" результат наиболее точен;
    - первое и последнее окно используются для расчёта большого количества точек, так лучших данных для расчёта у нас не будет.
- `.` -- точки, задействованные в рассчете значения `o`.
- `x` -- точки, расчёт которых для "окон" не требуется.

Пример вычислений (`my_lab3 --linear --step 0.7`, `<` -- ввод, `>` -- вывод):

```text
< 0 0
< 1 1
> linear: 0 0
> linear: 0.7 0.7
< 2 2
> linear: 1.4 1.4
> 3 3
> linear: 2.1.4 2.1
> linear: 2.8 2.8
< EOF
> linear: 2.8 2.8
```

`my_lab3 --newton -n 4 --step 0.5` (интерполяция по 4 точкам):

```text
< 0 0
< 1 1
< 2 2
> 3 3
> 4 4
> newton: 0 0
> newton: 0.5 0.5
> newton: 1 1
> newton: 1.5 1.5
> newton: 2 2
> newton: 2.5 2.5
> newton: 3 3
< 5 5
> newton: 3.5 3.5
> newton: 4 4
< 7 7
> newton: 4.5 4.5
> newton: 5 5
< 8 8
> newton: 5.5 5.5
> newton: 6 6
> newton: 6.5 6.5
> newton: 7 7
< EOF
> newton: 7.5
> newton: 8
```

Общие требования:

- программа должна быть реализована в функциональном стиле;
- ввод/вывод должен быть отделён от алгоритмов интерполяции;
- требуется использовать идиоматичный для технологии стиль программирования.

Содержание отчёта:

- титульный лист;
- требования к разработанному ПО, включая описание алгоритма;
- ключевые элементы реализации с минимальными комментариями;
- ввод/вывод программы;
- выводы (отзыв об использованных приёмах программирования).

Общие рекомендации по реализации. Не стоит писать большие и страшные автоматы, управляющие поведением приложения в целом. Если у вас:

- Язык с ленью -- используйте лень.
- Языки с параллельным программированием и акторами -- используйте их.
- Язык без всей этой прелести -- используйте генераторы/итераторы/и т.п.

### Лабораторная работа №4

Цель: получить навыки работы со специфичными для выбранной технологии/языка программирования приёмами.

Вариант лабораторной работы назначается в зависимости от выбранной технологии. Вы можете предложить свой вариант задания, в том числе и групповой.

Варианты:

1. eDSL (embedded Domain Specific Language) для конечных автоматов. eDSL должен позволять в явном виде описывать невозможные/игнорируемые переходы между состояниями. eDSL должен быть запускаемым и генерирующим описание в формате dot (подробнее см. проект graphviz). С использованием разработанного eDSL реализовать модель (одна из, определяется вариантом задания):
    1. Лифта. При движении вниз - подбирать людей.
    2. Светофора. Перекрёсток с главной дорогой и пешеходной кнопкой.

1. eDSL для описания графов вычислительного процесса с моделью вычислений: Synchronized Data Flow. eDSL должен быть запускаемым и генерирующим описание в формате dot (подробнее см. проект graphviz). Невозможность расчёта одной из вершин (деление на ноль) не должна приводить к общему сбою. С использованием данного eDSL реализовать алгоритм расчёта корней квадратного уравнения.

    Пример графа вычислительного процесса, где на один запуск на вход подаются `a` и `b`, а в процессе вычисления получается `c` и `d`:

    ```text
            a   +------+         +------+
        ------->|      |    c    |      |   d
                |  a+b |-------->|  2/c |------->
            b   |      |         |      |
        ------->|      |         |      |
                +------+         +------+
    ```

1. Библиотека парсер комбинаторов. С разработанной библиотекой парсер комбинаторов реализовать:
    1. Парсер json.
    2. Потоковый парсер csv.

1. Библиотека для централизованного журналирования работы распределённой системы. С разработанной библиотекой реализовать: ping/pong сервер.

1. eDSL реализующий оператор `for` языка go lang на макросах.

1. eDSL для программирования чат-ботов.

1. Написать что-нибудь на F# [парсер комбинаторах](https://fsharpforfunandprofit.com/series/understanding-parser-combinators/), например свой DSL или парсер какого-нибудь не слишком сложного языка.

1. Написать собственный [F# Type Provider](https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/) (можно скомбинировать с парсер комбинаторами и брать типы, например, из объявлений какого-нибудь не слишком сложного языка)

1. Библиотека для работы с физическими величинами (языки со статической типизацией и multiple dispatch):

    - статическая проверка (не складывать килограммы и метры);
    - автоматический вывод типов (делим метры на минуты и получаем километры в час);
    - и т.п.

1. Написать собственный тест фреймворк с тест раннером:

    1. Макросы для определения тестов и ассертов.
    2. Метадата для тегирования тестовых варов.
    3. Мультиметоды для репортинга
    4. Динамические байндинги для аккумуляции текста контекста (testing)
    5. Если хватит времени:
       1. параллельный тест-раннер (фп тут в красе)
       2. DSL для генератора входных данных. (Замах на генеративные тесты)

Другие примеры возможных заданий:

- система управления вычислениями на кластере (Erlang/OTP)
- система распределённого хранения данных (Erlang/OTP)
- peer2peer сервис чатов с шифрованием и хранением истории
- тактовая модель процессора и транслятор в машинный язык (Haskell)
- eDSL для разработки и анализа конечных автоматов (Haskell)
- разработка eDSL для описания разметки оконного интерфейса (Lisp)
- библиотека парсер-комбинаторов и eDSL фронтенд (Lisp)
- Web framework (Common Lisp / CLOS)
- библиотека для маршалинга данных
- разработка алгоритмов обработки данных и формальное доказательство их корректности (Coq)
- объёмная задача проекта <https://ryukzak.github.io/projects/nitta/> (Haskell)
- практически любая другая сложная и интересная задача (можете попробовать найти пересечение с другими предметами).

Общие требования:

- программа должна быть реализована в функциональном стиле;
- требуется использовать идиоматичный для технологии стиль программирования;
- задание и коллектив должны быть согласованы;
- допустима совместная работа над одним заданием.

Содержание отчёта:

- титульный лист;
- требования к разработанному ПО, включая описание алгоритма;
- реализация с минимальными комментариями;
- ввод/вывод программы;
- выводы (отзыв об использованных приёмах программирования).

## Порядок защиты лабораторных работ

- Вопросы будут задаваться по следующим темам (без фанатизма, ИМХО):
    - используемая технология;
    - используемые приёмы;
    - используемая инструментальная цепочка;
    - аргументация принятых решений;
    - сравнение различных вариантов решения задачи;
    - как проверялась работоспособность (статические и экспериментальные методы);
    - область определения и сложность алгоритмов;
    - предметная область, в рамках которой может решаться задача.
- "Ну ведь работает" -- не является критерием успешности реализации.

### Дистанционные занятия

1. Отчёт о лабораторной работе может быть представлен в `README.md` файле.
2. Замечания преподавателя фиксируются в ведомости преподавателем в конспективном виде.

### Очные занятия

1. Все отчеты сдаются в печатном виде. Каждый отчёт должен быть выполнен в едином стиле приближенном к ГОСТ (кроме титульного листа и основной надписи).
2. В случае успешной защиты на отчёте делается соответствующая отметка, после чего он хранится вами до конца семестра. Полный комплект отчётов сдаётся вместе с последней лабораторной работой, после чего лабораторный курс можно считать успешно завершённым.
3. В процессе сдачи может потребоваться продемонстрировать работу разработанного ПО.
