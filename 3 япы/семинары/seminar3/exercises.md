# Задания

### Вопрос

Проведите следующий код через препроцессор и изучите результат.

```nasm
; После этой строчки символ `x` везде будет заменён на строчку "Hello"
%define x "Hello"

; Пример использования:
db x
db x
db x
```

После `nasm -E questions/1.asm`:

```nasm
%line 6+1 questions/1.asm
db "Hello"
db "Hello"
db "Hello"
```

### Вопрос

Проведите следующие два фрагмента код через препроцессор и сравните результат.

1. 
```nasm
%define i 1
     
%define d i * 3
     
mov rax, d
     
; let's redefine i
%define i 100
mov rax, d
```

> =>

```nasm
%line 5+1 questions/2.1.asm
mov rax, 1 * 3
mov rax, 100 * 3
```

2. 

```nasm
%define i 1
     
%xdefine d i * 3
     
mov rax, d
     
; let's redefine i
%define i 100
mov rax, d
```

> =>

```nasm
%line 5+1 questions/2.2.asm
mov rax, 1 * 3
mov rax, 1 * 3
```

### Вопрос

Проведите следующий код через препроцессор и изучите результат. Что такое x? Скомпилируется ли эта программа?

```nasm
%define process(x) (x * 3 + 23)
     
mov rax,  process( 9 )
```
> =>

```nasm
%line 3+1 questions/3.asm
mov rax, (9 * 3 + 23)
```

### Вопрос

Проведите следующий код через препроцессор и изучите результат. Скомпилируется ли эта программа?

```nasm
%define process(x) (x * 3 + 23)
     
mov rax,  process( rcx )
```
> =>

```nasm
%line 3+1 questions/4.asm
mov rax, (rcx * 3 + 23)
```

### Вопрос

Проведите следующий код через препроцессор и изучите результат.
```nasm
%macro test 3
db %1
db %2 
db %3
%endmacro
     
test "hello", ",", " world"
```

> =>

```nasm
%line 2+1 questions/5.asm
db "hello"
db ","
db " world"
```

## Задание 1

Напишите многострочный макрос, чтобы он выделял в памяти строку из своих аргументов, разделенную запятыми. Например при передаче аргументов `hello`, `another` и `world` в результате в памяти была выделена строка `hello, another, world`.

За более подробной о макросах можно обратиться к [документации nasm](https://www.tortall.net/projects/yasm/manual/html/nasm-multi-line-macros.html).

[task1](./task1/main.asm):

    $ nasm -g task1/main.asm -felf64 -o hello.o
    $ ld -o hello hello.o
    $ ./hello
    hello, another, world


## Задание 2

На предыдущем семинаре вы работали с функцией `print_hex`. Создайте программу из трех файлов: первые два - это библиотека с функциями `print_hex` и `exit`, в третьем содержится метка `_start` и происходит вызов `print_hex`. Скомпилируйте их и запустите программу. (Создайте библиотеку `lib.asm` с двумя функциями: `print_hex` и `exit` для выхода из приложения. Напишите к ней заголовочный файл `lib.inc`. Протестируйте её, запустив функцию из другого файла с меткой `_start`.) В результате ваша программа должна состоять из трех файлов:

- `lib.asm` - файл с реализацией функций `print_hex` и `exit`.
- `lib.inc` - файл с заголовками функций `print_hex` и `exit`.
- `main.asm` - файл с функцией `_start`, вызывающей функции `print_hex` и `exit`.

[task2](./task2/)

    cd task2
    nasm -f elf64 -o lib.o lib.asm
    nasm -f elf64 -o main.o main.asm
    ld -o app lib.o main.o
    ./app

### Вопрос

Какие команды необходимы чтобы провести оба файла с кодом через весь цикл компиляции?

1. Необходимо объявить функции библиотек как глобальные метки, чтобы к ним можно было получить доступ извне.
2. Необходимо не забыть, что теперь функции из библиотек это функции и надо к ним добавить команду ret
3. В основном файле надо сделать `extern` имен функций, которые будут использоваться.

### Вопрос

Для чего метка `_start` помечается как `global`?

`global` предназначен для экспорта символов туда в сгенерированный объектный код. Символ `_start` помечается как глобальный, чтобы его имя добавлялось в объектный код. Компоновщик (`ld`) может прочитать этот символ в объектном коде и его значение, чтобы знать, где пометить точку входа в выходном исполняемом файле. Когда вы запускаете исполняемый файл, он начинается с того места, которое отмечено `_start` в коде.

`_start` используется `ld` сценарием компоновщика `binutils` по умолчанию в качестве точки входа.

### Вопрос

С помощью утилиты `nm` мы можем посмотреть содержание её таблицы символов; мы увидим в ней только два символа:  `message` и `_start`:

> nm symbols.o
> 00000000000000000 T _start
> 0000000000000000 d message

Объясните значение второго столбца.

Второй столбец - тип символа.

> T - The symbol is in the text (code) section.
> D - The symbol is in the initialized data section.

[Подробнее...](https://www.opennet.ru/man.shtml?topic=nm&category=1&russian=2)

### Вопрос

Мы будем изучать исполняемые и объектные файлы с помощью утилит `readelf`, `nm` и `objdump`. Разберитесь, как посмотреть таблицу символов в `.o`-файле с помощью всех трёх (`man` содержат нужную информацию). Каждый раз обращайте внимание, как помечаются локальные и глобальные символы.

Инструкции в объектном файле можно посмотреть так:

    > objdump -M intel-mnemonic -d symbols.o
    symbols.o:     file format elf64-x86-64

    Disassembly of section .text:

    0000000000000000 <.text>:
    0:   48 be 00 00 00 00 00    mov  rsi,0x0
    7:   00 00 00 


### Вопрос

Могут ли несколько `.o`-файлов содержать метки с одинаковым именем?

Нет, не могут, тогда возникнет ошибка в неоднозначности файлов (функций): `multiple definition of ...`.

### Вопрос

Выполните следущие команды. Изучите поля `Offset`, `Sym.Value`, `Sym. Name + Addend` и поймите, чему они соответствуют в выводе дизассемблера от `objdump`.

    > objdump -M intel-mnemonic -d symbols.o
    > readelf --relocs symbols.o

### Вопрос

Изучите таблицы символов в файлах из задания с функцией `print_hex`. Как `global` и `extern` влияют на содержимое таблиц символов?


## Задание 3

Напишите `makefile` для программы из текущего семинара, состоящей из двух файлов; в одном хранились функции `exit` и `print_hex`, а  в другом содержались их вызовы.

[task 3](./task3/Makefile)

    make app


### Вопрос

Необходимо, чтобы вы освоились с терминами. В контексте `make`, что такое `rule`, `target`, `prerequisites`?

- `rule` - Само правило, формата: `target: prerequisites \n tab команда`
- `target` - Имя файла для сборки
- `prerequisites` - Необходимые компоненты для выполнения правила

### Вопрос

Прочитайте [секцию 2.3](https://www.gnu.org/software/make/manual/make.html#How-Make-Works) в документации на `make`. Что будет если не указать цель явно?  Какая цель по-умолчанию выполняется первой? Всегда ли это `all`?

По умолчанию `make` начинается с первой цели (а не с целей, имена которых начинаются с `'.'` если они также не содержат один или несколько `'/'`). Это называется целью по умолчанию. Вы можете переопределить это поведение с помощью командной строки или с помощью специальной переменной `.DEFAULT_GOAL`.

Таким образом, когда вы дадите команду:

    make

`make` читает `make`-файл в текущем каталоге и начинает с обработки первого правила.

### Автоматические переменные

Для удобства написания `makefile` в нем можно используя автоматические переменные, фактические значения которых будут зависить от контекста.

Следующие автоматичесеие переменные помогут вам в написании ваших `makefile` файлов:

  
- `$@` - цель (имя файла для сборки) текущего правила.
- `$<` - первая зависимость текущего правила.
- `$?` - список всех зависимостей текущего правила, которые новее, чем цель текущего правила, разделенных пробелами.
- `$^` - список всех зависимостей текущего правила, разделенных пробелами. Повторные включения зависимостей удаляются (каждая зависимость включается в список ровно один раз).
- `$+` - список всех зависимостей текущего правила, разделенных пробелами. Повторные включения зависимостей **не** удаляются (зависимости перечисляются ровно в том порядке и количестве, как заданы в списке зависимостей).

Более подробно про автоматические переменные можно прочитать по ссылке
https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html.

## Задание 3.5

Перепишите `makefile` для `print_hex` написанного вами ранее так, чтобы использовать `phony targets`, переменные, автоматические переменные и шаблоны. Напишите `pattern rule`, которое подойдёт для создания объектного файла из любого ассемблерного файла и используйте его в своем `makefile` для `print_hex`.

[task3.5](./task3/Makefile3-5)

**Pattern rule**:

```makefile
ASM=nasm
ASMFLAGS=-f elf64
LD=ld

%.o: %.asm
	$(ASM) $(ASMFLAGS) -o $@ $<
```

## Задание 4

Напишите `makefile` для любой из ваших лабораторных по программированию с первого курса, для любой лабораторной по web-программированию, для первой или второй лабораторной по этому курсу,  или вообще для любой программы из более, чем двух файлов, которую вы когда-либо писали. Не забудьте про использование `phony target` для сборки программы и удаления временных файлов.

**Лабораторная работа №1 по Программированию**:

[task4](./task4/Makefile)
