# Задания

### Вопрос

Рассмотрите [пример работы с мьютексом](https://gitlab.se.ifmo.ru/programming-languages/cse-programming-languages-fall-2023/main/-/blob/master/seminar-8/mutex-example-1.c) (файл `mutex-example-1.c`). Что будет если [убрать использование мьютекса](https://gitlab.se.ifmo.ru/programming-languages/cse-programming-languages-fall-2023/main/-/blob/master/seminar-8/mutex-example.c) (файл `mutex-example.c`)? Объясните поведение.

- С мьютексом: `2000000`;
- Без мьютекса: число меньше `2000000`, причем каждый раз разный результат;

Это происходит из-за того, что операция `+= 1` не атомарная. Два потока могут читать одни и те же значения `value` и увеличивать их, а также перезаписывать `value`. например, оба потока считали и увеличили на единицу, но при записи первого и при перезаписи вторым потокам значения `value`, оно увеличилось только на `1`, а не на `2`. Отсюда и возникают потери при подсчёте в `value`.

### Вопрос

Подробнее про мьютексы читайте на стр. 374–377 учебника.

## Задание 0.5

Добавьте мьютекс в код из [предыдущего примера](https://gitlab.se.ifmo.ru/programming-languages/cse-programming-languages-fall-2023/main/-/blob/master/seminar-8/thread-example-1.c) для синхронизации вывода в функции `bad_print`.

    gcc -pthread task0.5/thread-example.c

[task0.5](./task0.5/)


### Вопрос

Разберите этот исходный файл.

```c
/* fork-example.c */

#include <unistd.h>
#include <stdio.h>

int main() {
  // pid_t это, как и int, численный тип для идентификаторов процессов
  pid_t pid = fork();
  // в зависимости от возвращаемого значения, которое попадёт в pid, 
  // мы поймём, находимся ли мы в родительском процессе или в дочернем.
  if (pid == 0) {
      printf("I am a child, pid was %d\n", pid);
      printf("Child's pid is %d\n", getpid());
  }
  else {
      printf("I am a parent, pid was %d\n", pid);
      printf("Parent's pid is %d\n", getpid());
  }
}
```

В примере текущий исполняемый процесс форкается, и в зависимости от `pid` текущего процесса выводятся разные строки.

Сначала выводится сообщение от родителя, потом от его форка.

Пример вывода программы:

> I am a parent, pid was 15748
> Parent's pid is 15747
> I am a child, pid was 0
> Child's pid is 15748

### Вопрос

Что именно возвращает `fork()` в родительском процессе? А что в дочернем? См. `man fork`.

В родительском процессе `fork()` возвращает `pid` дочернего процесса. В дочернем процессе `fork` возвращает `0` – это не `pid` чего-либо, это просто индикатор. 

Если `fork()` возвращает `-1`, это значит, что произошла ошибка (и дочерний процесс не был создан).

### Вопрос

Изучите данную программу. Скомпилируйте её, запустите. Проверьте правильность `PID` дочернего процесса с помощью `pstree` или иными способами. Изучите содержимое `/proc/PID/maps` для родительского и дочернего процессов, найдите общую область памяти.

```c
/* fork-example-1.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>

void* create_shared_memory(size_t size) {
  return mmap(NULL,
              size,
              PROT_READ | PROT_WRITE,
              MAP_SHARED | MAP_ANONYMOUS,
              -1, 0);
}


int main() {
  void* shmem = create_shared_memory(128);

  printf("Shared memory at: %p\n" , shmem);
  int pid = fork();

  if (pid == 0) {
    while (1);
  } else {
    printf("Child's pid is: %d\n", pid);
    while(1);
  }
}
```

Вывод программы:

    Shared memory at: 0x7f713950c000
    Child's pid is: 18540

`pid` текущего процесса - `18539`. Вывод `pstree 18539`:

    a.out───a.out

`cat /proc/18539/maps`:

```
55779b9fb000-55779ba1c000 rw-p 00000000 00:00 0                          [heap]
7f7139283000-7f7139285000 rw-p 00000000 00:00 0 
7f7139285000-7f71392ab000 r--p 00000000 103:07 11806590                  /usr/lib/libc.so.6
7f71392ab000-7f713940a000 r-xp 00026000 103:07 11806590                  /usr/lib/libc.so.6
7f713940a000-7f713945f000 r--p 00185000 103:07 11806590                  /usr/lib/libc.so.6
7f713945f000-7f71394c3000 r--p 001d9000 103:07 11806590                  /usr/lib/libc.so.6
7f71394c3000-7f71394c5000 rw-p 0023d000 103:07 11806590                  /usr/lib/libc.so.6
7f71394c5000-7f71394d4000 rw-p 00000000 00:00 0 
7f713950c000-7f713950d000 rw-s 00000000 00:01 28008                      /dev/zero (deleted)
7ffc1fd47000-7ffc1fd69000 rw-p 00000000 00:00 0                          [stack]
7ffc1fde8000-7ffc1fdec000 r--p 00000000 00:00 0                          [vvar]
7ffc1fdec000-7ffc1fdee000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
```


`cat /proc/18540/maps`:
```
55779b9fb000-55779ba1c000 rw-p 00000000 00:00 0                          [heap]
7f7139283000-7f7139285000 rw-p 00000000 00:00 0 
7f7139285000-7f71392ab000 r--p 00000000 103:07 11806590                  /usr/lib/libc.so.6
7f71392ab000-7f713940a000 r-xp 00026000 103:07 11806590                  /usr/lib/libc.so.6
7f713940a000-7f713945f000 r--p 00185000 103:07 11806590                  /usr/lib/libc.so.6
7f713945f000-7f71394c3000 r--p 001d9000 103:07 11806590                  /usr/lib/libc.so.6
7f71394c3000-7f71394c5000 rw-p 0023d000 103:07 11806590                  /usr/lib/libc.so.6
7f71394c5000-7f71394d4000 rw-p 00000000 00:00 0 
7f713950c000-7f713950d000 rw-s 00000000 00:01 28008                      /dev/zero (deleted)
7ffc1fd47000-7ffc1fd69000 rw-p 00000000 00:00 0                          [stack]
7ffc1fde8000-7ffc1fdec000 r--p 00000000 00:00 0                          [vvar]
7ffc1fdec000-7ffc1fdee000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
```

Общая память: `0x7f713950c000`.
В обоих процессах она есть:

    7f713950c000-7f713950d000 rw-s 00000000 00:01 28008 /dev/zero (deleted)


## Задание 1

Модифицируйте программу выше следующим образом:

- Необходимо выделить память для 10 чисел типа `int` и сделать её общей для родительского и дочернего процессов. Внесите туда числа от 1 до 10.
- Родительский процесс будет ждать завершения дочернего процесса с помощью `wait(NULL)`. После этого он должен вывести все 10 чисел на экран.
- Дочерний процесс считывает два числа с помощью `scanf`: индекс в массиве и новое значение. Он меняет соответствующее число в массиве и завершает свою работу.

[task1](./task1/)

Пример вывода программы:

    Shared memory at: 0x7fc3ae189000
    
    [child] Child's pid is: 21567
    [parent] array before: 
    1 2 3 4 5 6 7 8 9 10 

    [parent] wait for child process
    [child] enter index and new value: 
    1 70
    [child] finishing child process...
    [parent] array after: 
    1 70 3 4 5 6 7 8 9 10


### Вопрос

Рассмотрите [пример программы](https://gitlab.se.ifmo.ru/programming-languages/cse-programming-languages-fall-2023/main/-/blob/master/seminar-8/pipe-example-1.c), которая в дочернем потоке читает строки со входа и отправляет их родительскому процессу через конвейер. Нужно ли было в данном примере использовать специальное сообщение о завершении ввода из дочернего процесса?

Да, так как иначе дочерний процесс не выйдет из цикла чтения ввода пользователя.

## Задание 2

Попробуйте синхронизировать процессы из **Задания 1**, используя конвейеры. Теперь дочерний процесс будет сообщать родительскому об изменении данных, отправляя сообщение по конвейеру. При получении сообщения родительский процесс должен вывести массив на экран. Дочерний процесс будут продолжать ожидать ввод от пользователя и менять элементы массива пока не получит на вход отрицательный индекс - тогда он завершается.

[task2](./task2/)


### Вопрос

Подробнее про семафоры читайте на стр. 382–384 учебника.

### Вопрос

Чем семафоры отличаются от мьютексов? Чем семафор с двумя состояниями отличается от мьютекса?

Отличие мьютекса от двоичного семафора:

- мьютекс может быть освобожден только потоком, который его захватил;
- двоичный семафор может быть сигнализирован любым потоком (или процессом);

Мьютекс аналогичен принципам бинарного семафора с одним существенным отличием: принцип владения. Владение - это простая концепция, согласно которой, когда задача блокирует (приобретает) мьютекс, только она может разблокировать (освободить) его. Если задача пытается разблокировать мьютекс, который она не заблокировала (следовательно, не является владельцем), то возникает условие ошибки и, что наиболее важно, мьютекс не разблокирован. Если объект взаимного исключения не имеет права собственности, то, независимо от того, как он называется, это не мьютекс.

## Задание 3

Используйте семафор для синхронизации между процессами в **Задании 2**.

[task3](./task3/)


### Вопрос

В чём проблема в этом коде? Какие пары чисел могут быть выведены в зависимости от того, в каком порядке будут выполнены инструкции разных потоков? Какое влияние оказывают перестановки компилятором?

```c
int x = 0;
int y = 0;
void thread1() {
  x = 1;
  print(y);
}
void thread2() {
  y = 1;
  print(x);
}
```

Могут быть выведены пары `0 0`, если в результате реордеринга вывод выполняется до `x = 1`, `1 0`, `0 1` и `1 1`, если после `x = 1` начал выполняться `y = 1`, а только после этого вывод.

### Вопрос

Пусть произошли некоторые опасные реордеринги при компиляции. Будет ли из-за этого результат работы программы различным при каждом запуске?

Возможно, так как из-за этого потоки могут быть не синхронизированы и возникнет состояние гонки для данных.

### Вопрос

Если мы используем ассемблерные вставки в программы, как это связано с необходимостью добавлять в неё барьеры памяти на уровне компиляции?

## Задание 4

Разберите пример `cpu-reordering.c`; он дублирует пример с чтениями и записью в `x` и `y`, но прогоняет его множество раз. При этом семафоры используются чтобы программа запускала вычисления в каждом потоке и по завершению итерации ждала, пока второй поток завершит свою итерацию.

Объясните, как в этой программе используются семафоры и как происходит детектирование реордерингов. Затем попробуйте вставить полные барьеры времени компиляции туда, где это необходимо. Попробуйте также вариант с полным барьером для компиляции и с соответствующей инструкцией процессора для полного барьера. Объясните результаты.

На низком уровне мьютексы и другие примитивы синхронизации реализованы с помощью барьеров. Действия, которые в коде происходят до работы с мьютексом или семафором, не должны оказаться из-за реордерингов после них.

Не пользуйтесь `volatile` для синхронизации между потоками! Полное объяснение на стр.362–363 учебника.

[task4](./task4/)

Семафоры используются, чтобы при каждом запуске итерации в `thread0_impl`/`thread1_impl` в момент `sem_post` потоки подождали друг друга.

Детектирование реордерингов происходит когда мы проверяем, что `read0 == 0 && read1 == 0`, т.е. присвоение `readX` происходит до присвоения `x`/`y`.
